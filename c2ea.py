import nightmare, sys, csv, glob, os
import tkinter as tk
from tkinter import filedialog

def show_exception_and_exit(exc_type, exc_value, tb):
    import traceback
    traceback.print_exception(exc_type, exc_value, tb)
    input("Press Enter key to exit.")
    sys.exit(-1)

def getarglength(nmmentry):
    """takes the nmm entry object and returns the appropriate EA marker"""
    if (nmmentry.length==4) & (nmmentry.offset%4==0):
        return "WORD "
    elif (nmmentry.length==2) & (nmmentry.offset%2==0):
        return "SHORT "
    else:
        return "BYTE "

def addToInstaller(csvList,installername):
    """Takes a list of csv files and adds them to the EA installer"""
    with open(installername,"w") as myfile:
        myfile.write("//EA Table Installation file generated by c2ea.exe\n\n")
        myfile.write('#include "Table Definitions.txt"\n\n')

    for csv in csvList:
        nmpath = csv.replace(".csv",".nmm")
        nmm = nightmare.NightmareTable(nmpath)
        filename = csv.replace(".csv",".event") #I don't wanna use .txt because it conflicts, but this is supposed to be a text file!
        filename = filename.replace(os.getcwd()+'\\','')
        with open(installername,'a') as myfile:
            #myfile.write("ORG " + hex(nmm.offset) + '\n') Don't put the offset here, have it in the dmp.
            myfile.write('#include "' + filename + '"\n\n')

def process(inputCSV, index, rom):
    """Takes a csv and spits out an EA macro file (.event, but actually text). Requires a nmm with the same name in the same folder.""" #is it possible to tell if it's inline?
    inputNMM = inputCSV.replace(".csv",".nmm") #assume the same file name for now
    filename = inputCSV.replace(".csv",".event")
    nmm = nightmare.NightmareTable(inputNMM)
    rompath = rom
    macroArgs = [] #params for macro
    macroOutput = '' #expanded macro form
    outputlines = []
    originalOffset = nmm.offset
    tableOffset = originalOffset #this gets changed to whatever is in the first cell of the csv actually
    currlen = '' #because we start with BYTE
    fillwithzero = None

    for x in range(nmm.colNum):
        argx = "arg"+'{0:03d}'.format(x)
        macroArgs.append(argx) #arg000, arg001, arg002 etc up to 1000 columns.
        arglen = getarglength(nmm.columns[x]) #this gets the appropriate length string.
        if arglen!=currlen: #only append if needed else just add arg.
            if currlen!='': #this should only be on the first line
                macroOutput+=';'
            #assuming arglen does not equal currlen
            macroOutput+=(arglen + argx + ' ')
            currlen = arglen
        else:
            macroOutput+=(argx + ' ')

    with open(inputCSV, 'r') as myfile:
        table = csv.reader(myfile)
        tableOffset = next(table)[0]
        for row in table:
            outputline = "csvmacro" + '{0:03d}'.format(index) + "("
            items = zip(nmm.columns, row[1:])
            for entry, data in items:
                thisentry = ''
                #output.extend(int(data, 0).to_bytes(entry.length, 'little', signed=entry.signed))
                if data=='':
                    if fillwithzero == None:
                        fillwithzero = input("Warning: "+ inputCSV + " has a blank cell.\nContinue anyway? Fills cells with '0' (y/n)").strip().lower()=='y'
                    if fillwithzero==True:
                        data = '0'
                    else:
                        input("Press Enter to quit.")
                        sys.exit(-1)
                try:
                    arglen = getarglength(entry)
                    if (arglen=="WORD ")|(arglen=="SHORT "):
                        outputline += data + ','
                    else:
                        dt = int(data, 0).to_bytes(entry.length, 'little', signed=entry.signed) #this is a string i guess
                        for byte in dt:
                            thisentry += (hex(byte)+' ')
                        outputline += thisentry[:-1] + ','
                except ValueError: #if it's not a number, just add it directly
                    outputline += (data+',')
            outputline = outputline[:-1] + ')'
            outputlines.append(outputline)

    with open(filename, 'w') as dumpfile:
        inline = False
        #dumpfile.write('{\n#define csvmacro(')
        dumpfile.write("#define csvmacro" + '{0:03d}'.format(index) + "(")
        dumpfile.write(','.join(macroArgs)) #turns list into 'arg000,arg001' etc
        dumpfile.write(') "')
        dumpfile.write(macroOutput + '"\n\n') #e.g. BYTE arg000, WORD arg001, etc
        if tableOffset.strip()[0:6]=="INLINE":
            if rompath == None:
                root = tk.Tk()
                root.withdraw()
                rompath = filedialog.askopenfilename(filetypes=[("GBA files",".gba"),("All files",".*")],initialdir=os.getcwd(),title="Select ROM to use for repointing")
            label = tableOffset.replace("INLINE",'').strip()

            # Here we do *not* want to use PFinder
            # dumpfile.write("#inctext PFinder \"" + rompath + "\" " + hex(originalOffset) + " " + label + "\n\nALIGN 4\n" + label + ":\n")

            def pointer_iter(romFileName, value):
                target = value.to_bytes(4, 'little')

                with open(romFileName, 'rb') as rom:
                    offset = 0

                    while True:
                        word = rom.read(4)

                        if word == b'':
                            break

                        if word == target:
                            yield offset

                        offset += 4

            dumpfile.write("PUSH\n")

            for offset in pointer_iter(rompath, originalOffset | 0x8000000):
                dumpfile.write("ORG ${:X}\n".format(offset))
                dumpfile.write("POIN {}\n".format(label))

            dumpfile.write("POP\n")

            # There, much better :)

            dumpfile.write("ALIGN 4\n{}:\n".format(label))

            inline = True
        else:
            dumpfile.write("PUSH\nORG "+tableOffset+"\n")
        dumpfile.write('\n'.join(outputlines))
        if not inline:
                dumpfile.write("\nPOP")
        #dumpfile.write('\n}\n')
    print("Wrote to " + filename)
    return rompath


def main():
    sys.excepthook = show_exception_and_exit
    try:
        rom = sys.argv[1]
    except IndexError:
        rom = None
    csvList = glob.glob(os.getcwd() + '/**/*.csv',recursive=True)
    for index, csvfile in enumerate(csvList):
        rom = process(csvfile, index, rom)
    installername = "Table Installer.event"
    addToInstaller(csvList,installername)
    input("Press Enter to continue")

if __name__ == '__main__':
    main()
